---
title: "Data Analysis"
format: html
editor: visual
---

# Libraries

```{r Libraries}
library(rFIA)
library(dplyr)
library(ggplot2)
library(tibble)
library(tidyverse)
library(lme4)
library(knitr)
library(performance)
options(tibble.width = Inf)   # show all columnsoptions(digits = 10)          # show more digits
```

```{r}
options(
  tibble.print_max = Inf, 
  tibble.width = Inf,
  dplyr.print_min = Inf,
  dplyr.print_max = Inf,
  pillar.print_max = Inf
)

options(
  tibble.width = Inf,        # Don't truncate columns
  tibble.max_extra_cols = Inf,
  pillar.width = Inf,
  pillar.subtle = FALSE,
  width = 2000               # Console width (prevents cutting)
)
```

# Data Load

```{r Large Datasets causing timeout}
# large ones causing timeout, limit scope to the 3 states we can load
# options(timeout = 600)
#me <- getFIA(states = "ME")
#vt <- getFIA(states = "VT")
#ny <- getFIA(states = "NY")
#nh <- getFIA(states = "NH")

```

```{r Data Load}

# Initially Downloaded data using getFIA, Data then stored in offline folder

#Download separately to avoid timeout
#ct <- getFIA(states = "CT")
#ma <- getFIA(states = "MA")
#ri <- getFIA(states = "RI")
```

```{r folders}
#Create Folder and save files there
#dir.create("FIA_data")
#saveRDS(ct, "FIA_data/CT_FIA.rds")
#saveRDS(ma, "FIA_data/MA_FIA.rds")
#saveRDS(ri, "FIA_data/RI_FIA.rds")
```

```{r environment load}
# Load data from folder into environment
ct <- readRDS("FIA_data/CT_FIA.rds")
ri <- readRDS("FIA_data/RI_FIA.rds")
ma <- readRDS("FIA_data/MA_FIA.rds")
```

```{r Combined Dataset}
# Combine them, each state object has multiple data tables within it
#all_states <- list(CT = ct, VT = vt, NH = nh, ME = me, 
                  # MA = ma, NY = ny, RI = ri)
all_states <- list(CT = ct, MA = ma,RI = ri)
```

# EDA and Data Cleaning

```{r View all datasets}
#View(all_states)
```

## Connecticut

Start with one state first

### Key Tables

Tables we are interested in for our model:

-   PLOT - Plot information
-   TREE - Individual tree measurements
-   COND - Stand conditions and forest types
-   PLOTGEOM - Geographic/ecological classifications
-   TREE_GRM_COMPNENT - Pre-calculated growth rates
-   SURVEY - Survey metadata (measurement intervals)

### Tree Table

```{r}
# Load the library
library(readr)

# Export the data frame
write_csv(ct$TREE, file = "TREE.csv") 
```

#### Key columns to look at in TREE:

-   DIA (current diameter)
-   PREVDIA (previous diameter)
-   SPCD (species code)
-   STATUSCD (alive/dead)
-   INVYR (inventory year)

**Other Columns we may use:**

-   CN - unique identifier for a specific observation (tree measurement)
-   PREV_TREE_CN - Links to the previous observation's CN
-   SUBP - Subplot \# within a Plot
-   TREE - Tree \# within subplot

After review of FIA material, for a unique identifier by tree we will use PLOT + SUBP + TREE = Permanent tree identifier

```{r Tree dataset}
# Look at CT tree data
dim(ct$TREE)  # How many rows/columns?
names(ct$TREE)  # What columns exist?
head(ct$TREE)  # First few rows
```

```{r Tree Data Columns}
# Key columns to look for in TREE:
# - DIA (current diameter)
# - PREVDIA (previous diameter) 
# - SPCD (species code)
# - STATUSCD (alive/dead)
# - INVYR (inventory year)

ct$TREE %>%
  select(PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, DIA, PREVDIA, 
         INVYR, TPA_UNADJ) %>%
  head(20)

# Look at some examples with growth data
ct$TREE %>%
  filter(!is.na(DIA) & !is.na(PREVDIA)) %>%
  select(SPCD, DIA, PREVDIA, INVYR, STATUSCD) %>%
  head(20)

# How many trees have both current and previous diameter?
ct$TREE %>%
  summarize(
    total_trees = n(),
    has_current_dia = sum(!is.na(DIA)),
    has_prev_dia = sum(!is.na(PREVDIA)),
    has_both = sum(!is.na(DIA) & !is.na(PREVDIA))
  )


#Calculate % missing per column
missing_summary <- ct$TREE %>%
  select(PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, DIA, PREVDIA, 
         INVYR, TPA_UNADJ) %>%
  summarise(
    PLT_CN = 100 * sum(is.na(PLT_CN)) / n(),
    TREE = 100 * sum(is.na(TREE)) / n(),
    SUBP = 100 * sum(is.na(SUBP)) / n(),
    CONDID = 100 * sum(is.na(CONDID)) / n(),
    STATUSCD = 100 * sum(is.na(STATUSCD)) / n(),
    SPCD = 100 * sum(is.na(SPCD)) / n(),
    DIA = 100 * sum(is.na(DIA)) / n(),
    PREVDIA = 100 * sum(is.na(PREVDIA)) / n(),
    INVYR = 100 * sum(is.na(INVYR)) / n(),
    TPA_UNADJ = 100 * sum(is.na(TPA_UNADJ)) / n()
  )

# View Missing Summary Table
t(missing_summary)
```

#### Missing Data Summary:

-   **0% missing**: PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, INVYR (core identifiers)

-   **8.2% missing**: DIA

-   **57% missing**: PREVDIA (only remeasured trees have this)

-   **11.6% missing**: TPA_UNADJ (trees per acre adjustment)

It seems this table is every tree recorded but there are many trees which didn't have more than one measurement. With nearly 60% missing repeat measurements imputation is not recommended.

Lets see if there are patterns in what is missing:

```{r Remeasurements by Year}
options(tibble.print_max = Inf, tibble.width = Inf)
# Look at all inventory years
result <- ct$TREE %>%
  count(INVYR) %>%
  arrange(INVYR)

print(result, width = Inf)

# See which years have remeasurements
ct$TREE %>%
  group_by(INVYR) %>%
  summarize(
    total = n(),
    has_prevdia = sum(!is.na(PREVDIA)),
    pct_with_prev = round(100 * has_prevdia / total, 1)
  ) %>%
  arrange(INVYR)
```

#### The Pattern:

-   **1985-2007**: First measurements only (no PREVDIA - 0% have previous diameter with exception of a few in 1998)
-   **2008-2020**: Includes remeasurements (84-95% have PREVDIA)

We should at least limit the scope of our dataset to 2008 - 2020. We may restrict it further based on missingness in the other two state datasets.

#### Missingness 2008 - 2020

```{r Missingness of Remeasurement Years}
# How many trees have both current and previous diameter (2008-2020)?
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%  # Filter to remeasurement years
  summarize(
    total_trees = n(),
    has_current_dia = sum(!is.na(DIA)),
    has_prev_dia = sum(!is.na(PREVDIA)),
    has_both = sum(!is.na(DIA) & !is.na(PREVDIA))
  )

# Calculate % missing per column (2008-2020 only)
missing_summary_limited <- ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%  # Filter to remeasurement years
  select(PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, DIA, PREVDIA, 
         INVYR, TPA_UNADJ) %>%
  summarise(
    PLT_CN = 100 * sum(is.na(PLT_CN)) / n(),
    TREE = 100 * sum(is.na(TREE)) / n(),
    SUBP = 100 * sum(is.na(SUBP)) / n(),
    CONDID = 100 * sum(is.na(CONDID)) / n(),
    STATUSCD = 100 * sum(is.na(STATUSCD)) / n(),
    SPCD = 100 * sum(is.na(SPCD)) / n(),
    DIA = 100 * sum(is.na(DIA)) / n(),
    PREVDIA = 100 * sum(is.na(PREVDIA)) / n(),
    INVYR = 100 * sum(is.na(INVYR)) / n(),
    TPA_UNADJ = 100 * sum(is.na(TPA_UNADJ)) / n()
  )

# View Missing Summary Table
t(missing_summary_limited)
```

#### What's still missing?

Let's look at the STATUSCD (alive/dead) column to see if the missingness is due to tree death.

**FIA Status Codes:**

Let's Look at the codes in our data:

```{r Fia Status Code}
unique_statuscd <- ct$TREE %>%
  distinct(STATUSCD) %>%
  pull(STATUSCD)

print(unique_statuscd)
```

It Looks like there is an extra code "0" and "3"

Based other FIA online materials **STATUSCD = 3** typically means **"Removed/Cut"**, **STATUSCD = 0** means not tallied due to natural causes.

Let's check we have all the same codes for our date range:

```{r Fia Status Code Filtered Data}
unique_statuscd_2008_2020 <- ct$TREE %>%
  filter(INVYR >= 2008, INVYR <= 2020) %>%
  distinct(STATUSCD) %>%
  pull(STATUSCD)

unique_statuscd_2008_2020
```

0 remains but 3 is not used in recent years. Perhaps 0 has replaced 3 for removed/cut?

Let's check what codes were in earlier years and see if there were zeros

```{r Codes by Time Periods}

# Create a dataset with status codes grouped by time period
status_comparison <- ct$TREE %>%
  mutate(
    time_period = case_when(
      INVYR < 2008 ~ "Before 2008",
      INVYR >= 2008 ~ "2008-2020"
    ),
    status_label = case_when(
      STATUSCD == 0 ~ "0: Not tallied",
      STATUSCD == 1 ~ "1: Live",
      STATUSCD == 2 ~ "2: Dead",
      STATUSCD == 3 ~ "3: Removed",
      TRUE ~ as.character(STATUSCD)
    )
  ) %>%
  count(time_period, status_label) %>%
  group_by(time_period) %>%
  mutate(
    pct = 100 * n / sum(n)
  )

# View the data
status_comparison

# Alternative: Faceted plot (separate panels)
ggplot(status_comparison, aes(x = status_label, y = pct, fill = status_label)) +
  geom_col() +
  facet_wrap(~time_period) +
  labs(
    title = "Tree Status Distribution by Time Period",
    x = "Status Code",
    y = "Percentage of Trees (%)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )
```

It loooks like there was less untallied prior to 2008 3.6% –\> 7.4%

Also Removed trees before to after 2008 2.1% –\> 0%

It's plausible that removed trees are now part of the 0 category but may not account for the entire category. Since online materials describe the 0 status code as untallied due to natural causes I think we can assume trees in this category are dead trees though whether they are dead due to removal or natural causes is not certain.

**Our Data:**

-   **0** = Dead tree (gone)
-   **1** = Live tree
-   **2** = Dead tree (still standing)

Let's get back to the missing data. Now that we know that 0 and 2 are dead trees let's see if this relates to not having a measurement.

```{r Dead/Alive Trees}
# Of the trees missing DIA, what % are dead/alive?
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%  # Only look at trees missing DIA
  summarize(
    total_missing_dia = n(),
    n_dead = sum(STATUSCD %in% c(0, 2), na.rm = TRUE),  # 0 or 2 = dead
    n_alive = sum(STATUSCD == 1, na.rm = TRUE),
    pct_dead = 100 * n_dead / total_missing_dia,
    pct_alive = 100 * n_alive / total_missing_dia
  ) %>%
print(width = Inf)

# Of the trees missing PREVDIA, what % are dead/alive?
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(PREVDIA)) %>%  # Only look at trees missing PREVDIA
  summarize(
    total_missing_prevdia = n(),
    n_dead = sum(STATUSCD %in% c(0, 2), na.rm = TRUE),  # 0 or 2 = dead
    n_alive = sum(STATUSCD == 1, na.rm = TRUE),
    pct_dead = 100 * n_dead / total_missing_prevdia,
    pct_alive = 100 * n_alive / total_missing_prevdia
  ) %>%
print(width = Inf)

```

**Missing PREVDIA (Previous Diameter)**

-   "ingrowth" trees
-   **too small to measure in the previous inventory** (\< 5" DBH threshold)
-   grew large enough by 2008+ to be included in measurements
-   can't calculate growth rates for these trees (no baseline)

Missing DIA (Current Diameter)

-   Almost all trees missing current diameter are **dead or removed**
-   You can't measure the diameter of a tree that's gone (STATUSCD=0) or too deteriorated (STATUSCD=2)
-   The 39 live trees (1.3%) with missing DIA might be measurement errors or trees that couldn't be accessed

**Ingrowth Trees**

```{r Ingrowth Trees}
# Create dataset comparing ingrowth vs non-ingrowth trees
diameter_comparison <- ct$TREE %>%
  filter(
    INVYR >= 2008 & INVYR <= 2020,
    STATUSCD == 1,           # Live trees only
    !is.na(DIA)              # Has current diameter
  ) %>%
  mutate(
    tree_type = case_when(
      is.na(PREVDIA) | PREVDIA == 0 ~ "Ingrowth (no previous measurement)",
      TRUE ~ "Remeasured (has previous measurement)"
    )
  )

```

The trees we assume are Ingrowth Trees are definitely smaller as a group. But there seems to be some trees that are too large. These are likely trees that are being measured for the first time.

We understand the missing data problem now. Let's rerun for the combined TREE datasets across all states and then impute.

#### Missingness in full TREE dataset

```{r}
combined_tree %>%
  group_by(INVYR) %>%
  summarize(
    total = n(),
    has_prevdia = sum(!is.na(PREVDIA)),
    pct_with_prev = 100 * has_prevdia / total
  ) %>%
  arrange(INVYR) 
```

```{r Combined Tree Dataset}
 
# Combine TREE tables from all three states
combined_tree <- bind_rows(
  ct$TREE %>% mutate(STATE = "CT"),
  ma$TREE %>% mutate(STATE = "MA"),
  ri$TREE %>% mutate(STATE = "RI")
)
```

We will look at the dataset size of each state after we have filtered for years with remeasurements.

```{r}
# Calculate % missing per column (combined data)
missing_summary_combined <- combined_tree %>%
  select(PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, DIA, PREVDIA, 
         INVYR, TPA_UNADJ) %>%
  summarise(
    PLT_CN      = 100 * sum(is.na(PLT_CN)) / n(),
    TREE        = 100 * sum(is.na(TREE)) / n(),
    SUBP        = 100 * sum(is.na(SUBP)) / n(),
    CONDID      = 100 * sum(is.na(CONDID)) / n(),
    STATUSCD    = 100 * sum(is.na(STATUSCD)) / n(),
    SPCD        = 100 * sum(is.na(SPCD)) / n(),
    DIA         = 100 * sum(is.na(DIA)) / n(),
    PREVDIA     = 100 * sum(is.na(PREVDIA)) / n(),
    INVYR       = 100 * sum(is.na(INVYR)) / n(),
    TPA_UNADJ   = 100 * sum(is.na(TPA_UNADJ)) / n()
  )

# View Missing Summary Table (raw output) 
missing_summary_combined %>% as.data.frame() 
t(as.data.frame(missing_summary_combined))


# Remeasurement stats
combined_tree %>%
  group_by(INVYR) %>%
  summarize(
    total         = n(),
    has_prevdia   = sum(!is.na(PREVDIA)),
    pct_with_prev = 100 * has_prevdia / total
  ) %>%
  arrange(INVYR) %>%
  as.data.frame() %>%
  kable(caption = "Remeasurement Stats by Inventory Year")

# Patterns by state
combined_tree %>%
  group_by(STATE, INVYR) %>%
  summarize(
    total         = n(),
    has_prevdia   = sum(!is.na(PREVDIA)),
    pct_with_prev = 100 * has_prevdia / total
  ) %>%
  arrange(STATE, INVYR) %>%
  as.data.frame() %>%
  kable(caption = "Patterns of Remeasurements by State and Inventory Year")

# Compare missing data across states
combined_tree %>%
  group_by(STATE) %>%
  summarise(
    n_trees            = n(),
    pct_missing_DIA    = 100 * sum(is.na(DIA)) / n(),
    pct_missing_PREVDIA = 100 * sum(is.na(PREVDIA)) / n()
  ) %>%
  as.data.frame() %>%
  kable(caption = "Missing Data Percentages by State")


```

All states start remeasurements in 2008.

Check status codes are the same:

```{r check status codes all states}

unique_statuscd_2008_2020_all_states <- combined_tree %>%
  filter(INVYR >= 2008, INVYR <= 2020) %>%
  distinct(STATUSCD) %>%
  pull(STATUSCD)

unique_statuscd_2008_2020_all_states
```

Status codes are the same for all states

```{r}
# Of the trees missing DIA, what % are dead/alive?
dia_summary <- combined_tree %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%  # Only look at trees missing DIA
  summarize(
    total_missing_dia = n(),
    n_dead = sum(STATUSCD %in% c(0, 2), na.rm = TRUE),  # 0 or 2 = dead
    n_alive = sum(STATUSCD == 1, na.rm = TRUE),
    pct_dead = 100 * n_dead / total_missing_dia,
    pct_alive = 100 * n_alive / total_missing_dia
  )

kable(dia_summary, caption = "Percentage of Dead/Alive Trees Missing DIA")

# Of the trees missing PREVDIA, what % are dead/alive?
combined_tree %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(PREVDIA)) %>%  # Only look at trees missing PREVDIA
  summarize(
    total_missing_prevdia = n(),
    n_dead = sum(STATUSCD %in% c(0, 2), na.rm = TRUE),  # 0 or 2 = dead
    n_alive = sum(STATUSCD == 1, na.rm = TRUE),
    pct_dead = 100 * n_dead / total_missing_prevdia,
    pct_alive = 100 * n_alive / total_missing_prevdia
  ) %>%
print(width = Inf)
```

**Missing DIA (10,807 trees)**

-   **Dead: 10,615 trees (98.22%)** Expected - can't measure dead/removed trees

-   **Alive: 192 trees (1.78%)** - Small number of measurement errors

    ***(This is something we could impute but it is very small so if we don't have time for imputation it shouldn't strongly affect our overall conclusions)***

**Missing PREVDIA (8,595 trees)**

-   **Dead: 400 trees (4.65%)** - Some trees died before being remeasured
-   **Alive: 8,195 trees (95.35%)** Expected - these are **ingrowth trees**

```{r}
# Strict comparison: Only NA PREVDIA vs valid PREVDIA > 0
diameter_comparison <- combined_tree %>%
  filter(
    INVYR >= 2008 & INVYR <= 2020,
    STATUSCD == 1,           # Live trees only
    !is.na(DIA)              # Has current diameter
  ) %>%
  mutate(
    tree_type = case_when(
      is.na(PREVDIA) ~ "Ingrowth",
      PREVDIA > 0 ~ "Remeasured",
      TRUE ~ NA_character_  # Exclude PREVDIA = 0
    )
  ) %>%
  filter(!is.na(tree_type))  # Remove PREVDIA = 0 trees

# Summary table
diameter_summary <- diameter_comparison %>%
  group_by(tree_type) %>%
  summarise(
    n = n(),
    mean_dia = round(mean(DIA, na.rm = TRUE), 2),
    median_dia = round(median(DIA, na.rm = TRUE), 2)
  ) %>%
  as.data.frame()

# Display table
kable(diameter_summary, 
      caption = "Diameter Summary: Ingrowth vs Remeasured Trees",
      col.names = c("Tree Type", "N", "Mean (in)", "Median (in)"))
```

Smaller trees are in the ingrowth category indicating that these are likely trees which were too small to measure in previous years. We will move forward for now but a good next step for our analysis would be to investigate this category and get more certainty on the missing data. This may also be a category some data that would be a good candidate for imputation.

#### Remeasurement Checks

```{r}

# intervals dataset
intervals <- combined_tree %>%
  filter(INVYR >= 2008) %>%
  left_join(
    combined_tree %>% select(CN, INVYR) %>% rename(PREV_INVYR = INVYR),
    by = c("PREV_TRE_CN" = "CN")
  ) %>%
  mutate(years_between = INVYR - PREV_INVYR) %>%
  filter(!is.na(years_between), years_between > 0)

# Check intervals by state and year
intervals %>%
  group_by(STATE, INVYR) %>%
  summarise(
    n = n(),
    mean_interval = round(mean(years_between), 1),
    median_interval = median(years_between),
    min_interval = min(years_between),
    max_interval = max(years_between)
  ) %>%
  arrange(STATE, INVYR) %>%
  as.data.frame() %>%
  kable(caption = "Intervals by State and Year") # add kable here

# Are intervals consistent within each state?
intervals %>%
  group_by(STATE) %>%
  summarise(
    n = n(),
    mean_interval = round(mean(years_between), 1),
    sd_interval = round(sd(years_between), 1),
    most_common = median(years_between)
  ) %>%
  as.data.frame() %>%
  kable(caption = "Interval Consistency Statistics by State") # add kable here

# Distribution of intervals by state
intervals %>%
  count(STATE, years_between) %>%
  group_by(STATE) %>%
  mutate(pct = round(100 * n / sum(n), 1)) %>%
  arrange(STATE, years_between) %>%
  as.data.frame() %>%
  kable(caption = "Distribution of Intervals by State") # add kable here


# Visualization: Intervals by state
ggplot(intervals, aes(x = years_between, fill = STATE)) +
  geom_bar(position = "dodge") +
  labs(
    title = "Remeasurement Intervals by State",
    subtitle = "Are measurement cycles consistent?",
    x = "Years Between Measurements",
    y = "Count"
  ) +
  theme_minimal()

# Heatmap: Which years have which intervals?
intervals %>%
  count(STATE, INVYR, years_between) %>%
  ggplot(aes(x = INVYR, y = as.factor(years_between), fill = n)) +
  geom_tile() +
  facet_wrap(~STATE, ncol = 1) +
  scale_fill_gradient(low = "white", high = "#3498DB") +
  labs(
    title = "Measurement Intervals Over Time by State",
    x = "Inventory Year",
    y = "Years Since Previous Measurement",
    fill = "Count"
  ) +
  theme_minimal()
```

```{r}
# Show which previous years contribute to each current year
intervals %>%
  filter(INVYR %in% c(2018, 2019, 2020)) %>%  # Pick a few recent years
  count(STATE, INVYR, PREV_INVYR, years_between) %>%
  arrange(STATE, INVYR, years_between) %>%
  kable(caption = "Previous Measurement Years Contributing to 2018-2020")

# Summary: For each inventory year, what mix of intervals exists?
intervals %>%
  group_by(STATE, INVYR) %>%
  summarise(
    n_trees = n(),
    intervals_present = paste(sort(unique(years_between)), collapse = ", "),
    most_common = median(years_between),
    .groups = "drop"
  ) %>%
  kable(caption = "Mix of Measurement Intervals by State and Year")

# Check if specific plots have consistent intervals
intervals %>%
  group_by(STATE, PLOT) %>%
  summarise(
    n_measurements = n(),
    intervals = paste(sort(unique(years_between)), collapse = ", "),
    sd_interval = round(sd(years_between), 2),
    .groups = "drop"
  ) %>%
  filter(n_measurements > 1) %>%  # Only plots with multiple remeasurements
  arrange(STATE, PLOT) %>%
  head(20) %>%
  kable(caption = "Measurement Interval Consistency Within Plots (First 20 plots)")
```

### 1. **Multiple intervals exist within the same year**

Looking at 2020 for example:

-   **CT 2020:** Mix of 7-year intervals (last measured 2013)
-   **MA 2020:** Mix of 7-year intervals (last measured 2013)
-   **RI 2020:** Mix of 7-year intervals (last measured 2013)

But in 2018 and 2019, you see:

-   **2018:** Both 6-year (from 2012) and 7-year (from 2011) intervals
-   **2019:** Both 6-year (from 2013) and 7-year (from 2012) intervals

### 2. **Individual plots ARE fairly consistent**

The standard deviations are low (0.92 - 1.52), meaning:

-   Most plots stick to similar intervals across remeasurements
-   Example: Plot 51 has `sd = 0.00` - perfectly consistent 4-year intervals
-   Example: Plot 32 has `sd = 0.00` - perfectly consistent 6-year intervals
-   Most plots vary by only \~1 year between measurement cycles

### 3. **Different plots have different "schedules"**

-   Some plots: Consistent 4-year cycles (Plot 51, 101, 201, etc.)
-   Some plots: Consistent 5-7 year cycles
-   A few plots: Mix of 4, 5, 6, and 7-year intervals

**State Patterns:**

1.  **All three states follow similar patterns** - they're on the same measurement schedule
2.  **2018:** Dominated by 6-year intervals (plots last measured in 2012)
3.  **2019:** Mixed, shifting toward 7-year intervals (plots from 2012 and 2013)
4.  **2020:** All 7-year intervals (plots last measured in 2013)

**Interval Conclusion: Must include time interval as a variable unless we annualize the growth rate**

### Tree Growth Table

**TREE_GRM_COMPENT**

We also have the TREE_GRM_COMPNENT table. This should only include remeasured trees. We've analyzed the full TREE table with all the samples to understand what it is that's missing in the TREE_GRM_COMPENT table from the full tree dataset. Also this table is annualized so we won't need the interval as a predictor.

```{r}
# This table might have pre-calculated growth
head(ct$TREE_GRM_COMPONENT)
names(ct$TREE_GRM_COMPONENT)
dim(ct$TREE_GRM_COMPONENT)

# Look for growth-related columns
ct$TREE_GRM_COMPONENT %>%
  select(contains("DIA"), contains("GRM"), contains("GROW")) %>%
  head(20)
```

The TREE_GRM_COMPENT table does have **pre-calculated annual growth rates**

## Key columns we need:

-   **ANN_DIA_GROWTH** - Annual diameter growth
-   **DIA_BEGIN** - Starting diameter
-   **DIA_END** - Ending diameter
-   **TRE_CN** - Tree identifier (to join back to TREE table

```{r}
# Combine TREE_GRM_COMPONENT from all three states
combined_growth <- bind_rows(
  ct$TREE_GRM_COMPONENT %>% mutate(STATE = "CT"),
  ma$TREE_GRM_COMPONENT %>% mutate(STATE = "MA"),
  ri$TREE_GRM_COMPONENT %>% mutate(STATE = "RI")
)
nrow(combined_growth)

```

```{r}
# Look at the growth data
head(combined_growth %>% 
     select(TRE_CN, PLT_CN, DIA_BEGIN, DIA_END, ANN_DIA_GROWTH, STATE)) %>%
  kable(caption = "First Few Rows of Combined Growth Data")

# Summary statistics overall
summary(combined_growth$ANN_DIA_GROWTH)

# Summary by state
combined_growth %>%
  group_by(STATE) %>%
  summarise(
    n = n(),
    mean_growth = round(mean(ANN_DIA_GROWTH, na.rm = TRUE), 3),
    median_growth = round(median(ANN_DIA_GROWTH, na.rm = TRUE), 3),
    min_growth = round(min(ANN_DIA_GROWTH, na.rm = TRUE), 3),
    max_growth = round(max(ANN_DIA_GROWTH, na.rm = TRUE), 3),
    n_missing = sum(is.na(ANN_DIA_GROWTH))
  ) %>%
  kable(caption = "Annual Diameter Growth Summary by State")

# Remove any missing or weird values
growth_clean <- combined_growth %>%
  filter(!is.na(ANN_DIA_GROWTH),
    ANN_DIA_GROWTH >= 0)  # Positive growth only, negative doesn't make conceptual sense

# How many trees total and by state?
growth_clean %>%
  group_by(STATE) %>%
  summarise(n_trees = n()) %>%
  bind_rows(
    growth_clean %>% summarise(STATE = "TOTAL", n_trees = n())
  ) %>%
  kable(caption = "Number of Trees After Cleaning")

# Distribution - all states combined
hist(growth_clean$ANN_DIA_GROWTH, breaks = 50,
     main = "Annual Diameter Growth",
     xlab = "Growth (inches/year)",
     col = "#3498DB")

# Distribution by state (side-by-side)
ggplot(growth_clean, aes(x = ANN_DIA_GROWTH, fill = STATE)) +
  geom_histogram(bins = 50, alpha = 0.6, position = "identity") +
  labs(
    title = "Annual Diameter Growth Distribution by State",
    x = "Growth (inches/year)",
    y = "Count",
    fill = "State"
  ) +
  theme_minimal()

# Boxplot comparison
ggplot(growth_clean, aes(x = STATE, y = ANN_DIA_GROWTH, fill = STATE)) +
  geom_boxplot() +
  labs(
    title = "Annual Diameter Growth by State",
    x = "State",
    y = "Growth (inches/year)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

This is right skewed we should take the log of this:

```{r}
# Add log-transformed growth
growth_clean <- combined_growth %>%
  mutate(log_growth = log(ANN_DIA_GROWTH))

# Distribution - all states combined
hist(growth_clean$log_growth, breaks = 50,
     main = "Log Annual Diameter Growth",
     xlab = "Growth (inches/year)",
     col = "#3498DB")
```

There are big gaps let's find out why:

```{r}
# Check what's causing the gaps in log-transformed data
summary(combined_growth$ANN_DIA_GROWTH)

# Are there zeros or negative values?
combined_growth %>%
  summarise(
    n_total = n(),
    n_zero = sum(ANN_DIA_GROWTH == 0, na.rm = TRUE),
    n_negative = sum(ANN_DIA_GROWTH < 0, na.rm = TRUE),
    n_positive = sum(ANN_DIA_GROWTH > 0, na.rm = TRUE),
    min_value = min(ANN_DIA_GROWTH, na.rm = TRUE),
    max_value = max(ANN_DIA_GROWTH, na.rm = TRUE)
  ) %>%
  kable()

# Look at the distribution more carefully
combined_growth %>%
  filter(!is.na(ANN_DIA_GROWTH)) %>%
  count(ANN_DIA_GROWTH < 0) %>%
  kable(caption = "Are there negative growth values?")

# Check for very small values that might cause issues
combined_growth %>%
  filter(ANN_DIA_GROWTH > 0 & ANN_DIA_GROWTH < 0.01) %>%
  summarise(
    n_very_small = n(),
    examples = paste(head(ANN_DIA_GROWTH, 5), collapse = ", ")
  ) %>%
  kable()
```

Looking at this I realized I have zero growth values that will be lost with log.

**Problem:** 4,108 trees with no growth (ANN_DIA_GROWTH = 0)

-   `log(0)` is **undefined** (negative infinity)
-   R likely dropped these or created `-Inf` values

This doesn't account for there being gaps in different places though, but it's important to keep our 0 values as these are real cases of trees that didn't experience any annual growth.

Let's keep looking for the gaps

```{r}
# Look at the actual values in growth_clean
growth_clean %>%
  pull(ANN_DIA_GROWTH) %>%
  head(100)

# Are values discrete/rounded?
growth_clean %>%
  count(ANN_DIA_GROWTH) %>%
  arrange(desc(n)) %>%
  head(20) %>%
  kable(caption = "Most common growth values - Are they rounded?")

# Check if growth values are multiples of 0.01
growth_clean %>%
  mutate(
    rounded_to_hundredth = round(ANN_DIA_GROWTH, 2) == ANN_DIA_GROWTH
  ) %>%
  count(rounded_to_hundredth) %>%
  kable()

```

Gaps are due to transformation of discrete data.

**Original data (rounded to 0.01):**

-   You have: 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08...
-   These are discrete, evenly spaced values

**After log transformation:**

-   You have: log(0.01) = -4.605, log(0.02) = -3.912, log(0.03) = -3.507, log(0.04) = -3.219, log(0.05) = -2.996, log(0.06) = -2.813, log(0.07) = -2.659, log(0.08) = -2.526

gaps between log values are not equal anymore:

-   Gap between log(0.01) and log(0.02) = 0.693
-   Gap between log(0.07) and log(0.08) = 0.133

The gaps will be less prominent with square root and we want to keep our zeros.

Let's try square root transformation instead since we want to keep our zero growth values:

```{r}
growth_clean_sqrt <- growth_clean %>%
  mutate(sqrt_growth = sqrt(ANN_DIA_GROWTH))

hist(growth_clean_sqrt$sqrt_growth, breaks = 50,
     main = "Square Root-Transformed Growth (Keeps Zeros)",
     xlab = "sqrt(Growth)", col = "#3498DB")
```

```{r}
# Use the STATE column that's already in growth_clean
tree_measurements <- growth_with_ids %>%
  mutate(TREE_ID = paste(STATE, PLOT, SUBP, TREE, sep = "_")) %>%
  group_by(TREE_ID) %>%
  summarise(
    n_measurements = n(),
    years = paste(sort(unique(INVYR)), collapse = ", ")
  )

# Summary table
tree_measurements %>%
  count(n_measurements) %>%
  mutate(pct = round(100 * n / sum(n), 1)) %>%
  kable(caption = "Number of Measurements Per Tree",
        col.names = c("Measurements", "Number of Trees", "Percent"))
```

### Review TREE_ID as Unique Identifier

```{r}
# Pick a few trees with multiple measurements
example_trees <- model_data %>%
  group_by(TREE_ID) %>%
  filter(n() >= 3) %>%  # Trees with 3+ measurements
  arrange(TREE_ID, INVYR) %>%
  select(TREE_ID, PLOT_ID, STATE, INVYR, DIA_BEGIN, DIA_END, ANN_DIA_GROWTH) %>%
  ungroup()

# Show first few trees
example_trees %>%
  head(20) %>%
  kable(caption = "Example: Same Trees Measured Over Time")

# Pick one specific tree and show its full history
one_tree <- example_trees %>%
  filter(TREE_ID == first(TREE_ID)) %>%
  arrange(INVYR)

one_tree %>%
  kable(caption = "One Tree's Complete Measurement History")

# Verify the tree is growing (DIA should increase over time)
model_data %>%
  group_by(TREE_ID) %>%
  filter(n() >= 2) %>%
  arrange(TREE_ID, INVYR) %>%
  mutate(
    diameter_increases = DIA_END > lag(DIA_END)
  ) %>%
  filter(!is.na(diameter_increases)) %>%
  summarise(
    pct_increasing = round(100 * sum(diameter_increases) / n(), 1)
  ) %>%
  ungroup() %>%
  summarise(
    mean_pct_increasing = mean(pct_increasing)
  ) %>%
  kable()
```

### Review Forest Type

```{r}
# Forest type codes
head(ct$COND)
names(ct$COND)

# What forest types exist?
ct$COND %>%
  count(FORTYPCD) %>%
  arrange(desc(n))
```

# Model Dataset Creation

```{r}
# Create model dataset (starting from growth_clean which has filtering done)
model_data <- growth_clean %>%
  # Join with combined_tree to get PLOT, SUBP, TREE identifiers AND SPCD
  left_join(
    combined_tree %>% select(CN, PLOT, SUBP, TREE, CONDID, INVYR, SPCD),  # Added SPCD here
    by = c("TRE_CN" = "CN")
  ) %>%
  # Create IDs
  mutate(
    TREE_ID = paste(STATECD, PLOT, SUBP, TREE, sep = "_"),
    PLOT_ID = paste(STATECD, PLOT, sep = "_"),
    sqrt_growth = sqrt(ANN_DIA_GROWTH)  # Add sqrt transformation
  ) %>%
  # Join with COND for forest type
  left_join(
    bind_rows(
      ct$COND %>% mutate(STATE_COND = "CT"),
      ma$COND %>% mutate(STATE_COND = "MA"),
      ri$COND %>% mutate(STATE_COND = "RI")
    ) %>% select(PLT_CN, CONDID, FORTYPCD, STDAGE),
    by = c("PLT_CN", "CONDID")
  ) %>%
  # Join with PLOTGEOM for ecological subsection
  left_join(
    bind_rows(
      ct$PLOTGEOM %>% mutate(STATE_PLOT = "CT"),
      ma$PLOTGEOM %>% mutate(STATE_PLOT = "MA"),
      ri$PLOTGEOM %>% mutate(STATE_PLOT = "RI")
    ) %>% select(CN, ECOSUBCD, LAT, LON),
    by = c("PLT_CN" = "CN")
  )

# Check hierarchical structure
model_data %>%
  summarise(
    Level_5_Ecosubcd = n_distinct(ECOSUBCD),
    Level_4_States = n_distinct(STATE),
    Level_3_ForTypes = n_distinct(FORTYPCD),
    Level_2_Plots = n_distinct(PLOT_ID),
    Level_1_Trees = n_distinct(TREE_ID),
    Total_Observations = n()
  ) %>%
  kable(caption = "5-Level Hierarchical Structure")

# Distribution of measurements per tree
model_data %>%
  group_by(TREE_ID) %>%
  summarise(n_measurements = n()) %>%
  count(n_measurements) %>%
  mutate(pct = round(100 * n / sum(n), 1)) %>%
  kable(caption = "Measurements per Tree (Repeated Measures)")

# Save the dataset
saveRDS(model_data, "FIA_data/model_data_multilevel.rds")


```

# Modeling

**Fixed Effects:**

-   `STDAGE` = Stand age
-   `SPCD` = Species

**Random Effects (5 nested levels):**

-   Level 5: Ecological subsections (15) - broad climate/geography regions
-   Level 4: States (3) - CT, MA, RI
-   Level 3: Forest types (45) - nested within states
-   Level 2: Plots (1,080) - permanent monitoring locations
-   Level 1: Trees (36,574) - individual trees measured repeatedly over time

**Random Intercept:**

-   Each group (tree, plot, forest type, state, subsection) gets its own baseline growth rate
-   But the effect of predictors (FORTYPCD, STDAGE, SPCD) is assumed to be the same across all groups

Model Question: Do growth rates vary by forest type, stand age, and species while accounting for clustering at multiple geographic and ecological levels?

## Model 1

```{r}
# Build the 5-level model
model <- lmer(
  sqrt_growth ~ STDAGE + factor(SPCD) +
    (1 | ECOSUBCD / STATE / FORTYPCD / PLOT_ID / TREE_ID),
  data = model_data
)

# Model summary
summary(model)
```

## Model 1 Results:

### Fixed Effects:

**STDAGE (Stand Age):**

-   Coefficient: -0.000825 (p \< 0.001)
-   **Interpretation:** For each additional year of stand age, growth rate decreases by 0.000825 on the sqrt scale
-   **Makes biological sense:** Older stands have slower-growing trees

**SPCD (Species):**

-   Baseline species SPCD = 10
-   **Significantly slower growers than baseline:**
    -   Species 923: -0.313 (p \< 0.001) - slowest
    -   Species 763: -0.277 (p \< 0.001)
    -   Species 319: -0.254 (p \< 0.001)
    -   Species 421: -0.215 (p \< 0.001)
-   **Not significantly different from baseline:**
    -   Species 12, 57, 94, 125, 621, 833, 837 (p \> 0.05)

### Random Effects (Variance Components):

| Level                     | Variance | Interpretation                        |
|------------------|------------|-----------------------------|
| **Tree** (Level 1)        | 0.00447  | Largest - individual tree differences |
| **Plot** (Level 2)        | 0.00117  | Plot-level variation                  |
| **Forest Type** (Level 3) | 0.00016  | Forest type differences               |
| **State** (Level 4)       | 0.00006  | Small state-level differences         |
| **Ecosubcd** (Level 5)    | 0.00009  | Ecological subsection variation       |
| **Residual**              | 0.00135  | Unexplained variation                 |

```{r}
# Calculate ICC for all levels
icc_results <- icc(model, by_group = TRUE)
print(icc_results)

# Manual calculation to understand it better
variance_components <- as.data.frame(VarCorr(model))

variance_components %>%
  mutate(
    ICC = vcov / sum(vcov),
    Percent = round(100 * ICC, 2)
  ) %>%
  select(grp, vcov, ICC, Percent) %>%
  kable(caption = "Variance Partitioning (ICC) by Level",
        col.names = c("Level", "Variance", "ICC", "% of Total Variance"))

# Total variance
total_var <- sum(variance_components$vcov)

# Variance at each level
cat("\nVariance Decomposition:\n")
cat("Tree level:", round(100 * variance_components$vcov[1] / total_var, 2), "%\n")
cat("Plot level:", round(100 * variance_components$vcov[2] / total_var, 2), "%\n")
cat("Forest Type:", round(100 * variance_components$vcov[3] / total_var, 2), "%\n")
cat("State level:", round(100 * variance_components$vcov[4] / total_var, 2), "%\n")
cat("Ecosubcd level:", round(100 * variance_components$vcov[5] / total_var, 2), "%\n")
cat("Residual:", round(100 * variance_components$vcov[6] / total_var, 2), "%\n")
```

## ICC Findings:

### **Tree Level (61.26%)** - most important

-   **61% of variation in growth is between individual trees**
-   This confirms you NEED the multilevel structure with tree-level random effects
-   Individual tree characteristics (genetics, microsite conditions, competition) matter most

### **Plot Level (15.97%)** - important

-   **16% of variation is between plots**
-   Plot-level conditions (soil, topography, disturbance history) are meaningful
-   Justifies including plots as a grouping level

### **Forest Type (2.20%)** - small

-   Forest type adds modest variation
-   Could keep or remove this level

### **State (0.83%) & Ecosubcd (1.22%)** - very small

-   Combined \~2% of variation
-   These highest levels add little beyond plot and tree
-   **Could consider simplifying** to a 3-level model (Tree → Plot → Forest Type)

### **Residual (18.51%)** - Unexplained variation

-   Measurement error + unmeasured factors

Let's try removing state and ecosubcd.

## Model 2

```{r}
# Simpler 3-level model
model_simple <- lmer(
  sqrt_growth ~ STDAGE + factor(SPCD) +
    (1 | FORTYPCD / PLOT_ID / TREE_ID),
  data = model_data
)

summary(model_simple)
icc(model_simple, by_group = TRUE)
```

## Comparison: 5-Level vs 3-Level Model

| Model       | REML      | Tree ICC | Plot ICC | Upper Levels ICC    |
|-------------|-----------|----------|----------|---------------------|
| **5-level** | -246618.9 | 61.3%    | 16.0%    | 4.1% (FT+State+Eco) |
| **3-level** | -246611.8 | 60.5%    | 17.0%    | 4.2% (FT only)      |

### Model 1 vs Model 2:

1.  **Nearly identical fit** (REML values very close)
2.  **Same conclusions** - Tree (61%) and Plot (17%) variance dominate
3.  **Simpler is better** - State and Ecosubcd levels added complexity without improving fit
4.  **Forest Type still matters** (4.2% variance) - worth keeping

### Fixed Effects Evaluation:

### **STDAGE (Stand Age):**

-   Coefficient: -0.000826
-   **p \< 0.001**\* (highly significant)
-   Keep - evidence older stands have slower growth

### **SPCD (Species):**

Looking at the 93 species coefficients:

**Highly significant (p \< 0.001):**

-   Species 315, 319, 391, 421, 701, 763, 816, 922, 923, 927, etc.
-   Clear differences from baseline

**Marginally significant (p \< 0.05):**

-   Many more species (43, 68, 71, 91, 97, 130, etc.)

**Not significant (p \> 0.05):**

-   About 40-50 species show no difference from baseline

### Should We Keep Species?

Yes, because:

Many species ARE significantly different

Species is biologically important for growth

# References

**USFS Forest Inventory and Analysis (FIA) Program**

-   **Main site: <https://research.fs.usda.gov/programs/fia>**

-   **Data Download: <https://apps.fs.usda.gov/fia/datamart/datamart.html>**

-   **FIADB Population Estimation User Guide**: [**https://research.fs.usda.gov/understory/fiadb-population-estimation-user-guide**](https://research.fs.usda.gov/understory/fiadb-population-estimation-user-guide)

-   **FIA Database Description and Users Manual: <https://www.fs.usda.gov/rm/pubs/rmrs_gtr245.pdf>**

-   **Claude.ai: <https://claude.ai/new>**

# Supplementary Material

**GitHub Link:** [**https://github.com/rvithayathil/678-Final-Project**](https://github.com/rvithayathil/678-Final-Project)

**FIA Supplements:**

![](images/clipboard-122537803.png){width="490"}

![](images/clipboard-1989162094.png){width="491"}

![](images/clipboard-2792531723.png)
