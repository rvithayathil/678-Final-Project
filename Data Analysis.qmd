---
title: "Data Analysis"
format: html
editor: visual
---

```{r Libraries}
library(rFIA)
library(dplyr)
```

# Data Load

```{r Large Datasets causing timeout}
# large ones causing timeout, limit scope to the 3 states we can load
# options(timeout = 600)
#me <- getFIA(states = "ME")
#vt <- getFIA(states = "VT")
#ny <- getFIA(states = "NY")
#nh <- getFIA(states = "NH")

```

```{r Data Load}

# Initially Downloaded data using getFIA, Data then stored in offline folder

#Download separately to avoid timeout
#ct <- getFIA(states = "CT")
#ma <- getFIA(states = "MA")
#ri <- getFIA(states = "RI")
```

```{r}
#Create Folder and save files there
#dir.create("FIA_data")
#saveRDS(ct, "FIA_data/CT_FIA.rds")
#saveRDS(ma, "FIA_data/MA_FIA.rds")
#saveRDS(ri, "FIA_data/RI_FIA.rds")
```

```{r environment load}
# Load data from folder into environment
ct <- readRDS("FIA_data/CT_FIA.rds")
ri <- readRDS("FIA_data/RI_FIA.rds")
ma <- readRDS("FIA_data/MA_FIA.rds")
```

```{r Combined Dataset}
# Combine them, each state object has multiple data tables within it
#all_states <- list(CT = ct, VT = vt, NH = nh, ME = me, 
                  # MA = ma, NY = ny, RI = ri)
all_states <- list(CT = ct, MA = ma,RI = ri)
```

# Data Cleaning

```{r}
View(all_states)
```

## Connecticut

Start with one state first

### Key Tables

Tables we are interested in for our model:

-   PLOT - Plot information
-   TREE - Individual tree measurements
-   COND - Stand conditions and forest types
-   PLOTGEOM - Geographic/ecological classifications
-   TREE_GRM_COMPNENT - Pre-calculated growth rates
-   SURVEY - Survey metadata (measurement intervals)

### Tree Table

#### Key columns to look at in TREE:

-   DIA (current diameter)
-   PREVDIA (previous diameter)
-   SPCD (species code)
-   STATUSCD (alive/dead)
-   NVYR (inventory year)

```{r Tree dataset}
# Look at CT tree data
dim(ct$TREE)  # How many rows/columns?
names(ct$TREE)  # What columns exist?
head(ct$TREE)  # First few rows
```

```{r}
# Key columns to look for in TREE:
# - DIA (current diameter)
# - PREVDIA (previous diameter) 
# - SPCD (species code)
# - STATUSCD (alive/dead)
# - INVYR (inventory year)

ct$TREE %>%
  select(PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, DIA, PREVDIA, 
         INVYR, TPA_UNADJ) %>%
  head(20)

# Look at some examples with growth data
ct$TREE %>%
  filter(!is.na(DIA) & !is.na(PREVDIA)) %>%
  select(SPCD, DIA, PREVDIA, INVYR, STATUSCD) %>%
  head(20)

# How many trees have both current and previous diameter?
ct$TREE %>%
  summarize(
    total_trees = n(),
    has_current_dia = sum(!is.na(DIA)),
    has_prev_dia = sum(!is.na(PREVDIA)),
    has_both = sum(!is.na(DIA) & !is.na(PREVDIA))
  )



#Calculate % missing per column
missing_summary <- ct$TREE %>%
  select(PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, DIA, PREVDIA, 
         INVYR, TPA_UNADJ) %>%
  summarise(
    PLT_CN = 100 * sum(is.na(PLT_CN)) / n(),
    TREE = 100 * sum(is.na(TREE)) / n(),
    SUBP = 100 * sum(is.na(SUBP)) / n(),
    CONDID = 100 * sum(is.na(CONDID)) / n(),
    STATUSCD = 100 * sum(is.na(STATUSCD)) / n(),
    SPCD = 100 * sum(is.na(SPCD)) / n(),
    DIA = 100 * sum(is.na(DIA)) / n(),
    PREVDIA = 100 * sum(is.na(PREVDIA)) / n(),
    INVYR = 100 * sum(is.na(INVYR)) / n(),
    TPA_UNADJ = 100 * sum(is.na(TPA_UNADJ)) / n()
  )

# View Missing Summary Table
t(missing_summary)
```

#### Missing Data Summary:

-   **0% missing**: PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, INVYR (core identifiers)

-   **8.2% missing**: DIA

-   **57% missing**: PREVDIA (only remeasured trees have this)

-   **11.6% missing**: TPA_UNADJ (trees per acre adjustment)

It seems this table is every tree recorded but there are many trees which didn't have more than one measurement. With nearly 60% missing repeat measurements imputation is not recommended.

Lets see if there are patterns in what is missing:

```{r}
# Look at all inventory years
ct$TREE %>%
  count(INVYR) %>%
  arrange(INVYR)

# See which years have remeasurements
ct$TREE %>%
  group_by(INVYR) %>%
  summarize(
    total = n(),
    has_prevdia = sum(!is.na(PREVDIA)),
    pct_with_prev = round(100 * has_prevdia / total, 1)
  ) %>%
  arrange(INVYR)
```

#### The Pattern:

-   **1985-2007**: First measurements only (no PREVDIA - 0% have previous diameter with exception of a few in 1998)
-   **2008-2020**: Includes remeasurements (84-95% have PREVDIA)

We should at least limit the scope of our dataset to 2008 - 2020. We may restrict it further based on missingness in the other two state datasets.

#### Missingness 2008 - 2020

```{r}
# How many trees have both current and previous diameter (2008-2020)?
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%  # Filter to remeasurement years
  summarize(
    total_trees = n(),
    has_current_dia = sum(!is.na(DIA)),
    has_prev_dia = sum(!is.na(PREVDIA)),
    has_both = sum(!is.na(DIA) & !is.na(PREVDIA))
  )

# Calculate % missing per column (2008-2020 only)
missing_summary_limited <- ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%  # Filter to remeasurement years
  select(PLT_CN, TREE, SUBP, CONDID, STATUSCD, SPCD, DIA, PREVDIA, 
         INVYR, TPA_UNADJ) %>%
  summarise(
    PLT_CN = 100 * sum(is.na(PLT_CN)) / n(),
    TREE = 100 * sum(is.na(TREE)) / n(),
    SUBP = 100 * sum(is.na(SUBP)) / n(),
    CONDID = 100 * sum(is.na(CONDID)) / n(),
    STATUSCD = 100 * sum(is.na(STATUSCD)) / n(),
    SPCD = 100 * sum(is.na(SPCD)) / n(),
    DIA = 100 * sum(is.na(DIA)) / n(),
    PREVDIA = 100 * sum(is.na(PREVDIA)) / n(),
    INVYR = 100 * sum(is.na(INVYR)) / n(),
    TPA_UNADJ = 100 * sum(is.na(TPA_UNADJ)) / n()
  )

# View Missing Summary Table
t(missing_summary_limited)
```

#### What's still missing?

Let's look at the STATUSCD (alive/dead) column to see if the missingness is due to tree death.

**FIA Status Codes:**

![](images/clipboard-122537803.png){width="451"}

-   **1** = Live tree
-   **2** = Dead tree

```{r}
# Of the trees missing DIA, what % are dead/removed?
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%  # Only look at trees missing DIA
  summarize(
    total_missing_dia = n(),
    n_dead = sum(STATUSCD == 2, na.rm = TRUE),
    n_removed = sum(STATUSCD == 3, na.rm = TRUE),
    n_alive = sum(STATUSCD == 1, na.rm = TRUE),
    pct_dead = 100 * n_dead / total_missing_dia,
    pct_removed = 100 * n_removed / total_missing_dia,
    pct_alive = 100 * n_alive / total_missing_dia
  )

# Of the trees missing PREVDIA, what % are dead/removed?
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(PREVDIA)) %>%  # Only look at trees missing PREVDIA
  summarize(
    total_missing_prevdia = n(),
    n_dead = sum(STATUSCD == 2, na.rm = TRUE),
    n_removed = sum(STATUSCD == 3, na.rm = TRUE),
    n_alive = sum(STATUSCD == 1, na.rm = TRUE),
    pct_dead = 100 * n_dead / total_missing_prevdia,
    pct_removed = 100 * n_removed / total_missing_prevdia,
    pct_alive = 100 * n_alive / total_missing_prevdia
  )

# Cleaner crosstab for missing DIA
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  count(STATUSCD) %>%
  mutate(
    pct = round(100 * n / sum(n), 1),
    status_label = case_when(
      STATUSCD == 0 ~ "Unknown",
      STATUSCD == 1 ~ "Live",
      STATUSCD == 2 ~ "Dead", 
      STATUSCD == 3 ~ "Removed",
      TRUE ~ "Other"
    )
  ) %>%
  select(STATUSCD, status_label, n, pct)
```

```{r}
# See ALL status codes for missing DIA trees
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  count(STATUSCD) %>%
  mutate(
    pct = round(100 * n / sum(n), 1),
    status_label = case_when(
      STATUSCD == 0 ~ "Unknown",
      STATUSCD == 1 ~ "Live",
      STATUSCD == 2 ~ "Dead", 
      STATUSCD == 3 ~ "Removed",
      TRUE ~ as.character(STATUSCD)  # Show any other codes
    )
  ) %>%
  arrange(STATUSCD)

# Total count to verify
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  summarize(total = n())
```

```{r}
# Check if STATUSCD 3 exists
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  count(STATUSCD, sort = TRUE)

# Or check for any NA status codes
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  summarize(
    n_status_0 = sum(STATUSCD == 0, na.rm = TRUE),
    n_status_1 = sum(STATUSCD == 1, na.rm = TRUE),
    n_status_2 = sum(STATUSCD == 2, na.rm = TRUE),
    n_status_3 = sum(STATUSCD == 3, na.rm = TRUE),
    n_status_NA = sum(is.na(STATUSCD))
  )
```

```{r}
# See ALL unique status codes (not just 0, 1, 2, 3)
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  pull(STATUSCD) %>%
  unique() %>%
  sort()

# Or check the full range
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  group_by(STATUSCD) %>%
  summarize(n = n()) %>%
  arrange(STATUSCD)

# Double-check the count function isn't dropping rows
ct$TREE %>%
  filter(INVYR >= 2008 & INVYR <= 2020) %>%
  filter(is.na(DIA)) %>%
  nrow()
```

We also have the TREE_GRM_COMPNENT table. This should only include remeasured trees.

```{r}
# This table might have pre-calculated growth
head(ct$TREE_GRM_COMPONENT)
names(ct$TREE_GRM_COMPONENT)
dim(ct$TREE_GRM_COMPONENT)

# Look for growth-related columns
ct$TREE_GRM_COMPONENT %>%
  select(contains("DIA"), contains("GRM"), contains("GROW")) %>%
  head(20)
```

The `TREE_GRM_COMPONENT` table has **pre-calculated annual growth rates**

## Key columns we need:

-   **ANN_DIA_GROWTH** - Annual diameter growth (already calculated!)
-   **DIA_BEGIN** - Starting diameter
-   **DIA_END** - Ending diameter
-   **TRE_CN** - Tree identifier (to join back to TREE table)

```{r}
# Look at the growth data
head(ct$TREE_GRM_COMPONENT %>% 
     select(TRE_CN, PLT_CN, DIA_BEGIN, DIA_END, ANN_DIA_GROWTH))

# Summary statistics
summary(ct$TREE_GRM_COMPONENT$ANN_DIA_GROWTH)

# Remove any missing or weird values
growth_clean <- ct$TREE_GRM_COMPONENT %>%
  filter(!is.na(ANN_DIA_GROWTH),
         ANN_DIA_GROWTH > 0,  # Positive growth only
         ANN_DIA_GROWTH < 2)  # Remove outliers (>2 inches/year is suspicious)

# How many trees?
nrow(growth_clean)

# Distribution
hist(growth_clean$ANN_DIA_GROWTH, breaks = 50,
     main = "Annual Diameter Growth",
     xlab = "Growth (inches/year)")
```

```{r}
# Check what's actually in PLOTGEOM
names(ct$PLOTGEOM)
```

```{r}
# Create final dataset
analysis_data <- growth_clean %>%
  # Join to TREE table for species info
  left_join(ct$TREE %>% select(CN, SPCD, STATUSCD, INVYR),
            by = c("TRE_CN" = "CN")) %>%
  # Join to COND for forest type and stand age
  left_join(ct$COND %>% select(PLT_CN, CONDID, FORTYPCD, STDAGE),
            by = "PLT_CN") %>%
  # Join to PLOTGEOM for ecological codes and location
  left_join(ct$PLOTGEOM %>% select(CN, LAT, LON, ECOSUBCD),
            by = c("PLT_CN" = "CN"))

# Check the result
dim(analysis_data)
names(analysis_data)

# Summary statistics
analysis_data %>%
  summarize(
    n_trees = n(),
    n_plots = n_distinct(PLT_CN),
    n_subsections = n_distinct(ECOSUBCD, na.rm = TRUE),
    n_forest_types = n_distinct(FORTYPCD, na.rm = TRUE),
    mean_growth = mean(ANN_DIA_GROWTH, na.rm = TRUE),
    mean_dia_begin = mean(DIA_BEGIN, na.rm = TRUE),
    pct_with_ecosubcd = 100 * sum(!is.na(ECOSUBCD)) / n()
  )

# What subsections exist?
analysis_data %>%
  count(ECOSUBCD, sort = TRUE)

# What forest types?
analysis_data %>%
  count(FORTYPCD, sort = TRUE) %>%
  head(10)
```

```{r}
# Create growth variable
tree_growth <- ct$TREE %>%
  filter(!is.na(DIA) & !is.na(PREVDIA)) %>%
  mutate(
    diameter_change = DIA - PREVDIA,
    # Will need measurement interval to calculate annual growth
    # This comes from joining with other tables
  )

dim(tree_growth)
summary(tree_growth$diameter_change)
```

```{r}
# Look at plot structure
head(ct$PLOT)
names(ct$PLOT)

# Check measurement years
ct$PLOT %>%
  count(INVYR) %>%
  arrange(INVYR)
```

```{r}
# Forest type codes
head(ct$COND)
names(ct$COND)

# What forest types exist?
ct$COND %>%
  count(FORTYPCD) %>%
  arrange(desc(n))
```

```{r}
# Ecological codes
head(ct$PLOTGEOM)
names(ct$PLOTGEOM)

# What provinces/subsections?
ct$PLOTGEOM %>%
  count(ECOPROVCD) %>%
  arrange(desc(n))

ct$PLOTGEOM %>%
  count(ECOSUBCD) %>%
  arrange(desc(n))
```

```{r}
head(ma)
```

```{r}
names(ct)
```

```{r}
head(ri)
```

# References

**USFS Forest Inventory and Analysis (FIA) Program**

-   **Main site: <https://research.fs.usda.gov/programs/fia>**

-   **Data Download: <https://apps.fs.usda.gov/fia/datamart/datamart.html>**

-   **FIADB Population Estimation User Guide**: [**https://research.fs.usda.gov/understory/fiadb-population-estimation-user-guide**](https://research.fs.usda.gov/understory/fiadb-population-estimation-user-guide)

**Claude.ai: <https://claude.ai/new>**
